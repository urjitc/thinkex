import { db } from "@/lib/db/client";
import { deepResearchUsage } from "@/lib/db/schema";
import { and, gte, eq, asc, ne } from "drizzle-orm";
import { sql } from "drizzle-orm";
import { logger } from "@/lib/utils/logger";

const LIMIT = 2;
const WINDOW_MS = 24 * 60 * 60 * 1000; // 24 hours

export interface RateLimitResult {
  allowed: boolean;
  remaining: number;
  resetAt: Date | null;
  error?: string;
}

export interface ReservationResult extends RateLimitResult {
  usageId: string | null;
  wasDuplicate: boolean;
}

/**
 * Reserve a deep research usage slot atomically.
 * Uses atomic INSERT...SELECT to prevent race conditions (works with connection pooling).
 *
 * @param userId - The user requesting the deep research
 * @param workspaceId - The workspace context (nullable)
 * @param requestId - Unique idempotency key for this request (should be generated by caller)
 * @returns ReservationResult with usageId if allowed
 */
export async function reserveDeepResearchUsage(
  userId: string,
  workspaceId: string | null,
  requestId: string
): Promise<ReservationResult> {
  try {
    const result = await db.execute(sql`
      SELECT * FROM reserve_deep_research_usage(
        ${userId}::text,
        ${workspaceId}::uuid,
        ${requestId}::text,
        ${LIMIT}::integer,
        ${WINDOW_MS}::bigint
      )
    `);

    if (!result || result.length === 0) {
      logger.error("‚ùå [RATE-LIMIT] No result from reserve_deep_research_usage");
      return {
        allowed: false,
        remaining: 0,
        resetAt: null,
        usageId: null,
        wasDuplicate: false,
        error: "Unable to verify usage limit. Please try again.",
      };
    }

    const row = result[0] as {
      allowed: boolean;
      remaining: number;
      reset_at: string | null;
      usage_id: string | null;
      was_duplicate: boolean;
    };

    return {
      allowed: row.allowed,
      remaining: row.remaining,
      resetAt: row.reset_at ? new Date(row.reset_at) : null,
      usageId: row.usage_id,
      wasDuplicate: row.was_duplicate,
    };
  } catch (error) {
    logger.error("‚ùå [RATE-LIMIT] Database error in reserveDeepResearchUsage:", error);
    // Fail-closed: deny on error to prevent abuse during outages
    return {
      allowed: false,
      remaining: 0,
      resetAt: null,
      usageId: null,
      wasDuplicate: false,
      error: "Unable to verify usage limit. Please try again.",
    };
  }
}

/**
 * Complete a reservation after successful operation.
 * Updates the usage record with the real interactionId.
 *
 * @param usageId - The usage record ID from reserveDeepResearchUsage
 * @param interactionId - The real interaction ID from Google API
 */
export async function completeDeepResearchUsage(
  usageId: string,
  interactionId: string
): Promise<boolean> {
  try {
    const result = await db.execute(sql`
      SELECT complete_deep_research_usage(
        ${usageId}::uuid,
        ${interactionId}::text
      ) as success
    `);

    const success = (result?.[0] as { success: boolean } | undefined)?.success === true;
    if (!success) {
      logger.warn("‚ö†Ô∏è [RATE-LIMIT] Failed to complete usage record:", { usageId, interactionId });
    }
    return success;
  } catch (error) {
    logger.error("‚ùå [RATE-LIMIT] Error completing usage:", error);
    return false;
  }
}

/**
 * Mark a reservation as failed (rollback).
 * This frees up the quota slot for the user.
 *
 * @param usageId - The usage record ID from reserveDeepResearchUsage
 */
export async function failDeepResearchUsage(usageId: string): Promise<boolean> {
  try {
    const result = await db.execute(sql`
      SELECT fail_deep_research_usage(${usageId}::uuid) as success
    `);

    const success = (result?.[0] as { success: boolean } | undefined)?.success === true;
    logger.debug("üîÑ [RATE-LIMIT] Failed/rolled back usage:", { usageId, success });
    return success;
  } catch (error) {
    logger.error("‚ùå [RATE-LIMIT] Error failing usage:", error);
    return false;
  }
}

/**
 * Read-only check for UI purposes (showing remaining count without recording).
 */
export async function getDeepResearchUsageStatus(
  userId: string
): Promise<{ remaining: number; resetAt: Date | null }> {
  try {
    const windowStart = new Date(Date.now() - WINDOW_MS);
    const usages = await db
      .select({ createdAt: deepResearchUsage.createdAt })
      .from(deepResearchUsage)
      .where(
        and(
          eq(deepResearchUsage.userId, userId),
          gte(deepResearchUsage.createdAt, windowStart.toISOString()),
          ne(deepResearchUsage.status, "failed")
        )
      )
      .orderBy(asc(deepResearchUsage.createdAt));

    const remaining = Math.max(0, LIMIT - usages.length);
    let resetAt: Date | null = null;

    if (remaining === 0 && usages.length > 0) {
      const oldest = new Date(usages[0].createdAt);
      const calculatedReset = new Date(oldest.getTime() + WINDOW_MS);
      resetAt = calculatedReset > new Date() ? calculatedReset : new Date(Date.now() + 60000);
    }

    return { remaining, resetAt };
  } catch {
    return { remaining: 0, resetAt: null };
  }
}
